class Chain:
    min_score:int
    max_distance:int
    def __init__(self, min_score, max_distance):
        self.min_score = min_score
        self.max_distance = max_distance

    def chain_anchors(self, matches):
        # Filter and sort matches
        matches = [match for match in matches if match[2] >= self.min_score]
        matches.sort(key=lambda x: x[0])

        n = len(matches)
        dp = [0] * n  # dp[i] stores the best score ending at matches[i]
        backtrack = [-1] * n  # backtrack[i] stores the previous match in the optimal chain

        # Initialize DP with individual match scores
        for i in range(n):
            dp[i] = matches[i][2]  # Starting score is the match score

        # Fill DP table
        for i in range(1, n):
            for j in range(i):
                start_i, end_i, score_i = matches[i]
                start_j, end_j, score_j = matches[j]
                
                gap = start_i - end_j
                if gap <= self.max_distance:
                    penalty = max(0, gap - self.max_distance)
                    potential_score = dp[j] + score_i - penalty
                    
                    if potential_score > dp[i]:
                        dp[i] = potential_score
                        backtrack[i] = j

        # Find the best overall score and reconstruct the optimal chain
        max_index = max(range(n), key=lambda i: dp[i])
        max_score = dp[max_index]

        # Reconstruct the optimal chain
        optimal_chain = []
        current = max_index
        while current != -1:
            optimal_chain.append(matches[current])
            current = backtrack[current]

        optimal_chain.reverse()

        return optimal_chain, max_score



def test_chaining():
    # Create sample matches: (start, end, score)
    matches = [
        (100, 150, 30),  # match 1
        (200, 250, 35),  # match 2
        (120, 170, 40),  # match 3 (overlaps with match 1)
        (500, 550, 50),  # match 4 (distant)
        (450, 500, 45),  # match 5 (near match 4)
        (10, 50, 25)     # match 6 (low score, should not chain)
    ]

    # Initialize the chaining algorithm with a minimum score of 30
    chain = Chain(min_score=30, max_distance=50)

    # Perform chaining
    optimal_chain, max_score = chain.chain_anchors(matches)

    # Print the result
    print(f"Optimal Chain: {optimal_chain}")
    print(f"Maximum Score: {max_score}")


test_chaining()
