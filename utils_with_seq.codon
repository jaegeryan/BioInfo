from bio import *
import sys

def read_fasta(filename):
    """
    Read sequences from a FASTA file
    
    Args:
        filename: FASTA file path
    
    Returns:
        List of (header, sequence) tuples
    """
    sequences = List[Tuple[str, seq]]()
    try:
        for record in FASTA(filename):
            sequences.append((record.name, record.seq))
    except IOError as e:
        print(f"Error reading file {filename}: {e}", file=sys.stderr)
        sys.exit(1)
    return sequences

def read_fastq(filename):
    """
    Read sequences from a FASTQ file
    
    Args:
        filename: FASTQ file path
    
    Returns:
        List of (name:str, read:seq, qual:str, seq:seq) tuples
    """
    sequences = List[Tuple[str, seq, str, seq]]()
    try:
        for record in FASTQ(filename):
            sequences.append((record.name,    # str
                            record.read,      # seq
                            record.qual,      # str
                            record.seq))      # seq
    except IOError as e:
        print(f"Error reading file {filename}: {e}", file=sys.stderr)
        sys.exit(1)
    return sequences

def revcomp(seq):
    return ~seq

# The example of using Seq/Codon's method to get minimizers
def get_kmers(seq, k: Static[int] = 15, w: Static[int] = 10):
    """
    Get minimizers from sequence using sliding window approach (minimap2 style)
    
    Args:
        seq: DNA sequence
        k: k-mer length (default: 15, minimap2's default)
        w: window size (default: 10, minimap2's default)
    
    Returns:
        List of minimizer k-mers
    """
    result = List[Kmer[k]]()
    
    if len(seq) < k:
        return result
        
    # store k-mers in the current window
    window = List[Kmer[k]]()
    
    # initialize the first window
    for i in range(min(w, len(seq) - k + 1)):
        kmer = Kmer[k](seq[i:i+k])
        # take the smaller one between the k-mer and its reverse complement
        window.append(min(kmer, ~kmer))
    
    # find the minimum k-mer in the first window
    if len(window) > 0:
        min_kmer = window[0]
        for kmer in window:
            if kmer < min_kmer:
                min_kmer = kmer
        result.append(min_kmer)
    
    # slide the window to process the remaining sequence
    for i in range(w, len(seq) - k + 1):
        # add the new k-mer to the window
        new_kmer = Kmer[k](seq[i:i+k])
        window.append(min(new_kmer, ~new_kmer))
        
        # remove the oldest k-mer
        if len(window) > w:
            window = window[1:]
            
        # find the minimum k-mer in the current window
        min_kmer = window[0]
        for kmer in window:
            if kmer < min_kmer:
                min_kmer = kmer
        result.append(min_kmer)
    
    return result

@tuple
class BaseCount:
    A: int
    C: int
    G: int
    T: int

def count_bases(seq: str) -> BaseCount:
    """
    Count bases in sequence
    
    Args:
        seq: DNA sequence
    
    Returns:
        BaseCount object with A,C,G,T counts
    """
    dna_seq = s"{seq}";
    a,c,g,t = 0,0,0,0
    
    match dna_seq:
        case 'A*': a += 1
        case 'C*': c += 1
        case 'G*': g += 1
        case 'T*': t += 1
        
    return BaseCount(a,c,g,t)

def align_sequences(seq1: str, seq2: str) -> Tuple[str, int]:
    """
    Align two sequences
    
    Args:
        seq1: First sequence
        seq2: Second sequence
    
    Returns:
        Tuple of (CIGAR string, alignment score)
    """
    # 使用@操作符进行序列比对
    aln = s"{seq1}" @ s"{seq2}"
    return (str(aln.cigar), aln.score)