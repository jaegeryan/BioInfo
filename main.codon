from bio import *
import sys
from src.sketch import Minimizer
from src.index import Index
from src.chain import Chain
from src.align import Aligner
from src.utils import read_fasta, read_fastq

"""
Main function for minimap2 implementation
Usage: codon main.codon [options] <ref.fa> <query.fq> > approx-mapping.paf

Options:
  -x STR      preset: sr, map-pb, map-ont, asm5, asm10 or splice
  -n INT      mininum number of minimizers
  -m INT      mininum chaining score
  -k INT      k-mer length
  -w INT      minimizer window length
  -r INT      band width
  -c          output the cs tag
  -M          output the MD tag
"""

def parse_args():
    # default parameters
    params = {
        'preset': None,
        'min_cnt': None,
        'min_chain_score': None,
        'k': 15,
        'w': 10,
        'bw': None,
        'out_cs': False,
        'out_MD': False
    }
    
    args = sys.argv[1:]
    i = 0
    while i < len(args):
        if args[i].startswith('-'):
            if args[i] == '-x':
                params['preset'] = args[i+1]
                i += 2
            elif args[i] == '-n':
                params['min_cnt'] = int(args[i+1])
                i += 2
            elif args[i] == '-m':
                params['min_chain_score'] = int(args[i+1])
                i += 2
            elif args[i] == '-k':
                params['k'] = int(args[i+1])
                i += 2
            elif args[i] == '-w':
                params['w'] = int(args[i+1])
                i += 2
            elif args[i] == '-r':
                params['bw'] = int(args[i+1])
                i += 2
            elif args[i] == '-c':
                params['out_cs'] = True
                i += 1
            elif args[i] == '-M':
                params['out_MD'] = True
                i += 1
        else:
            break
    
    # check if the number of input files is correct
    if len(args[i:]) != 2:
        print(__doc__)
        sys.exit(1)
    
    return params, args[i], args[i+1]

def get_preset_params(preset: str) -> dict:
    """Return preset parameters"""
    if preset == "sr":  # short read
        return {'k': 15, 'w': 10, 'min_chain_score': 40}
    elif preset == "map-pb":  # PacBio reads
        return {'k': 15, 'w': 5, 'min_chain_score': 30}
    elif preset == "map-ont":  # Oxford Nanopore reads
        return {'k': 15, 'w': 5, 'min_chain_score': 30}
    elif preset == "asm5":  # asm-to-ref mapping, divergence <= 5%
        return {'k': 19, 'w': 10, 'min_chain_score': 50}
    elif preset == "asm10":  # asm-to-ref mapping, divergence <= 10%
        return {'k': 19, 'w': 10, 'min_chain_score': 50}
    elif preset == "splice":  # long-read spliced alignment
        return {'k': 15, 'w': 5, 'min_chain_score': 30}
    return {}

def main():
    # parse arguments
    params, ref_file, query_file = parse_args()
    
    # if preset is specified, update parameters
    if params['preset']:
        preset_params = get_preset_params(params['preset'])
        params.update(preset_params)
    
    # Read reference sequences
    references = read_fasta(ref_file)
    
    # Build index
    index = Index(k=params['k'], w=params['w'], 
                 min_cnt=params['min_cnt'])
    for header, seq in references:
        index.build(seq)
    
    # Process queries
    queries = read_fastq(query_file)
    
    # Initialize components
    chain = Chain(min_score=params['min_chain_score'])
    aligner = Aligner(bandwidth=params['bw'])
    
    # Process each query
    for qheader, qseq in queries:
        # Find matches
        matches = index.query(qseq)
        
        # Chain matches
        chains = chain.chain_anchors(matches)
        
        # Align and output results
        for ref_header, ref_seq in references:
            for chain in chains:
                alignment = aligner.align(qseq, ref_seq, chain,
                                       out_cs=params['out_cs'],
                                       out_MD=params['out_MD'])
                # output PAF format
                print(f"{qheader}\t{len(qseq)}\t{alignment}")

if __name__ == "__main__":
    main()